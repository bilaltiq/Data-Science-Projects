---
title: "Prep7S24"
author: "Bilal Tariq"
date: "2024-03-29"
format: pdf
editor: visual
---

```{r}
#| label: load-packages
#| include: false

library(tidyverse)
library(kableExtra)
library(igraph) # may need to install once; networks
library(igraphdata) # may need to install once; networks
library(ggplot2)
library(sf)
library(ggspatial)
library(leaflet)


# add other packages here for the spatial work

```

Reminder: Prep assignments are to be completed individually. Upload a final copy of the .Qmd and renamed .pdf to your private repo, and submit the renamed pdf to Gradescope before the deadline (Sunday night, 3/31/24, by midnight).

# Reading

The associated reading for the week is Chapter 20 on networks and Chapter 17 on spatial data. For Chapter 17, the focus is on working with spatial data, which basically means, making maps and showing appropriate data on them.

\newpage

# 1 - Basic Graph Concepts with a Toy Graph

Use the following generated graph to answer the questions that follow. Do NOT change the seed.

```{r}
set.seed(231)
g <- erdos.renyi.game(n = 10, p = 0.3)
plot(g)
```

> part a - How many vertices does the graph, g, have? How many edges?

Solution: It has 10 vertices and 12 edges

```{r}

vertices <- vcount(g)
edges <- ecount(g)

cat(vertices, edges)


```

> part b - Compute the diameter of the graph. Then identify a path with that length.

Hint: More than one path may have a length equal to the diameter. Remember that diameter is not the longest path possible. It is the longest of all the shortest paths. To identify a path, list the vertices involved such as 1-2-3 (this is not an actual path in this graph).

Solution: The diameter is 5. The path along this diameter is 4-7-2-9-5-8

```{r}

diameter <- diameter(g)

cat(diameter,", ")

#to identifyt the path with that legngth

path <- get_diameter(g)
cat(path)

```

> part c - Compute the degree for vertex 7 without using an R command. Explain what this number represents.

Solution: This will be the number of edges incident on it. In this case, the degree of vertex 7 will be 5. This just shows a degree of centrality, showing how connected vertex 7 is in the cluster.

part d - Looking at the plot of the graph, identify a vertex triple - three vertices which are connected by edges. Is your selected vertex triple closed - i.e. is it a triangle?

This is asking you to find a set of vertices that could form a triangle - at least 2 of the 3 potential edges should be there. Determining the fraction of actual triangles out of possible triangles is a measure of what is called the clustering present in the network.

You can list your triple with node numbers. E.G. 1-2-8 (not an actual triple in this graph). The idea would be that 1-2 is an edge and 2-8 is an edge. If 1-8 is also an edge, this would be a triangle.

Solution: 7 - 6 - 4 (closed triangle)

> part e - Imagine you have to walk along this graph. Walking around, what vertices are you most likely to visit often if you move around randomly? (What vertices help connect others a lot?)

No computations necessary here - you don't need to solve this formally - just think through it and give a guess. If you really want, you could look up a formal definition for a random walk on a graph. Basically, at any vertex, you have an equal probability of going to any vertices it has an edge to. For example, in this graph, if you were at vertex 3, you'd have a 50% chance of going to vertex 1 and 50% chance of going to vertex 7.

Solution: Vertex 7 and vertex 9 seem to be the most likely visits.

> part f - Compute betweenness centrality for all vertices. Identify the top 3 vertices in terms of betweeness. How do these vertices relate to those you listed in part e?

Solution: From the betweeness values, we see that 7 has a betweeness of 19.5 and 4 has a betweeness of 15.0. The vertex 9 has a betweenness of 12.0. The correspond to what I stated above except for 4.

```{r}

betweenness <- betweenness(g)

kable(betweenness)
```

<!-- Remember to commit and push as you go! -->

\newpage

# 2 - Exploring a Social Network

For this question, we'll explore a famous social network example known as "Zachary's Karate Club". This is information about a Karate club from 1970-1972 that split into 2 factions/groups based on a rift between members denoted "A" for "John A" and "H" for "Mr Hi" in the data set (these are not real names). Let's investigate a little bit!

```{r}
# Visualize the network
# Igraph default plot, may not be "pretty"
data(karate)
karate <- upgrade_graph(karate) # used due to changes in igraph
plot(karate)
```

> part a - Plot and describe the degree distribution of the karate network.

Hint: ggplot2 requires data to be in a data.frame to plot, so the code below will get you the degree distribution in data set to use, along with faction information for later use.

```{r}
faction <- get.vertex.attribute(karate)$Faction
kdegree <- degree(karate)
karatedata <- data.frame(kdegree, faction)
```

Solution:

```{r}

df <- karatedata$kdegree


```

> part b - Identify the individuals with the top 5 highest degree values. Do they include "John A" and "Mr Hi"?

Solution:

```{r}

```

> part c - Determine the eigenvector centrality of all vertices. Identify the individuals with the top 5 eigenvector centrality values. Do they include "John A" and "Mr Hi"?

Hint: The igraph command is eigen_centrality.

Solution:

```{r}

```

> part d - We investigated k-means as a method of clustering observations to find natural groups. Clustering can be performed on networks, though very different methods are needed to do so. Run the code below to perform a clustering analysis on this network. Then use the provided output to assess whether the clusters found match the provided factions assigned in the network by the researcher who studied the karate club. What did you find? Describe the findings in a few sentences.

Note: This clustering analysis may not find just 2 clusters.

```{r}
#| warning: false
#| message: false

# run clustering on karate network
# this is just one example clustering algorithm for a network
kclusters <- leading.eigenvector.community(karate)
# number of clusters
length(kclusters)
# size of each cluster
sizes(kclusters)

#how to plot the solution
plot(kclusters, karate) 

# Get cluster memberships to compare to faction
karatedata <- karatedata %>%
  mutate(clusters = as.numeric(membership(kclusters)))
mosaic::tally(clusters ~ faction, data = karatedata)
```

Solution:

\newpage

# 3 - Spatial data basics

Chapter 17 introduces a number of spatial data specific terms.

> part a - What are two examples of spatial data structure formats?

Solution: Shapefile and KML

> part b - What does `EPSG` stand for in `EPSG codes`? Why is it important to know the `EPSG` number, if applicable for your map?

Solution: It stands for Eurpoean Petroleum Survey group and it's important to know them as they can be used to identify coordinates in data so in our scenario, we can make a plot of the geospatial data.

> part c - What is the primary package used in the textbook to work with spatial data?

Solution: We will be working with the sf package.

> part d - What term/concept did you find hardest to understand from the reading?

Solution: I currently can't seem to understand the concept of layers such as the st_layers function.

\newpage

# 4 - Reproducing a map

Section 17.1 introduces *shapefiles*, and includes an example of working with a shapefile to re-create Snow's cholera map. This exercise mostly follows along with the text code.

> Setup

Load the **sf** package in the `setup` code chunk. Verify your working directory is the folder *this* .Rmd file is in. Then, create a *data* subfolder in this directory.

> part a - Run the code below line-by-line to understand what each part is doing. You can use *command + enter* or *ctrl + enter* to run one selected or highlighted set of code at a time. Confirm that you get a figure similar to that of Figure 17.3 in the textbook.

<!-- Only need to run this code one time interactively, so setting eval = FALSE so we don't run it again every time we knit -->

```{r}
#| label: download-files
#| eval: false

# Download SnowGIS_SHP zip file
download.file("http://rtwilson.com/downloads/SnowGIS_SHP.zip",
              destfile = "data/SnowGIS_SHP.zip")

# Unzip file in same folder
unzip(zipfile = "data/SnowGIS_SHP.zip",
      exdir = "data")
```

```{r}
# Create filepath to unzipped files so we don't need to re-type
data_path <- "data/SnowGIS_SHP"

# List files in SnowGIS_SHP
list.files(data_path)

# List layers
st_layers(data_path)

# Load second layer
cholera_deaths <- st_read(data_path, layer = "Cholera_Deaths")

class(cholera_deaths)
head(cholera_deaths)

# Context-less plot
ggplot(cholera_deaths) + 
  geom_sf()
```

Solution: Yes, we got exactly a map like displayed in fig 17.3

```{=html}
<!--
Did you get a map like displayed in Figure 17.3? Write a sentence above. 
-->
```
> part b - Now use the **ggspatial** package to overlay the London street map. Make sure you (install then) load the **ggspatial** package in the `setup` code chunk before running the code. What is wrong with this map?

```{r}
# if you get an error that a package is missing, you may
# need to install some dependencies
ggplot(cholera_deaths) + 
  annotation_map_tile(type = "osm", zoomin = 0) + 
  geom_sf(aes(size = Count), alpha = 0.7)
```

Solution: The dots representing the deaths are off by hundreds of metres.

> part c - Set the coordinates from the cholera data as the `espg:27700` coordinate system using `st_set_crs()`, then transform them to the `espg:4326` system using `st_transform()`, and finally plot the new, correctly projected data. What does "crs" stand for in this code?

```{r}
cholera_latlong <- cholera_deaths %>% 
  st_set_crs(27700) %>% 
  st_transform(4326)

ggplot(cholera_latlong) + 
  annotation_map_tile(type = "osm", zoomin = 0) + 
  geom_sf(aes(size = Count), alpha = 0.7)
```

Solution: It stands or coordinate reference system.

> part d - Repeat the layer loading and coordinate transformation procedure to add the water pumps to the plot. Looking at your plot, do you agree that the water pump on Broad Street seems to have been the problem for this outbreak?

```{r}
pumps_latlong <- st_read(data_path, layer = "Pumps") %>% 
  st_set_crs(27700) %>% 
  st_transform(4326)

ggplot(cholera_latlong) + 
  annotation_map_tile(type = "osm", zoomin = 0) + 
  geom_sf(aes(size = Count), alpha = 0.7) +
  geom_sf(data = pumps_latlong, size = 3, color = "red")
```

Solution: Yes, it seems as though the water pump on broad street was indeed the cause of the cholera outbreak as it has a high centrality and is in the middle of the region where the cholera cases were recorded.

> part e - Finally, try out the code below to create a dynamic map using the **leaflet** package (install and load as before!). Zoom in and out of the map to confirm that (1) there is a death in the middle of Hopkins Street, and (2) there is a pump near the intersection of Broadwick Street and Lexington Street. What seem to be the main types of businesses along the modern day Kingly street (look left of the pump)?

```{=html}
<!--
Dynamic plot will not knit to pdf so set `eval: false`
-->
```
```{r}
#| eval: false #because it would print static, just turn off

# create dynamic map
leaflet() %>% 
  addTiles() %>%
  addCircleMarkers(data = cholera_latlong,
                   radius =  ~ Count,
                   color = "navy",
                   stroke = FALSE,
                   fillOpacity = 0.7) %>% 
  addCircleMarkers(data = pumps_latlong,
                   radius = 6,
                   color = "red",
                   stroke = FALSE,
                   fillOpacity = 0.7)
```

Solution: There seems to be a lot of clothing brands, a shoe shop, and a lot of food brands on Kingly street.

```{=html}
<!--
Be sure to answer the question about business here, since we can't print the dynamic map.
-->
```
```{=html}
<!--
Remember to do the final commit + push, this time including your renamed pdf, and upload to Gradescope.
-->
```
